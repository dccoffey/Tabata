<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Tabata Exercise Selector</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #4fc3f7;
            text-shadow: 0 0 20px rgba(79, 195, 247, 0.3);
        }

        /* Selected Exercises Display */
        .selected-exercises {
            background: linear-gradient(145deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(79, 195, 247, 0.2);
        }

        .selected-exercises h2 {
            text-align: center;
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .exercise-slots {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 12px;
        }

        .exercise-slot {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .exercise-slot.filled {
            background: rgba(79, 195, 247, 0.1);
            border-color: rgba(79, 195, 247, 0.3);
        }

        .exercise-slot .number {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #1a1a2e;
            flex-shrink: 0;
        }

        .exercise-slot .exercise-info {
            flex: 1;
        }

        .exercise-slot .exercise-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: #fff;
        }

        .exercise-slot .exercise-name a {
            color: #4fc3f7;
            text-decoration: none;
            transition: color 0.2s;
        }

        .exercise-slot .exercise-name a:hover {
            color: #81d4fa;
            text-decoration: underline;
        }

        .exercise-slot .exercise-name a::after {
            content: " üé¨";
            font-size: 0.8em;
        }

        .exercise-slot .exercise-category {
            font-size: 0.85rem;
            color: #90a4ae;
            margin-top: 3px;
        }

        .exercise-slot.empty .exercise-name {
            color: #546e7a;
            font-style: italic;
        }

        /* Slot action buttons */
        .exercise-slot .slot-actions {
            display: flex;
            gap: 5px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .exercise-slot .slot-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.85rem;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        .exercise-slot .slot-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .exercise-slot .slot-btn.refresh-btn:hover {
            background: rgba(79, 195, 247, 0.3);
            color: #4fc3f7;
        }

        .exercise-slot .slot-btn.replace-btn:hover {
            background: rgba(102, 187, 106, 0.3);
            color: #66bb6a;
        }

        .exercise-slot .slot-btn.remove-btn:hover {
            background: rgba(239, 83, 80, 0.3);
            color: #ef5350;
        }

        /* Replace mode indicator */
        .replace-mode-indicator {
            display: none;
            text-align: center;
            padding: 15px;
            background: rgba(255, 152, 0, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #ff9800;
        }

        .replace-mode-indicator.active {
            display: block;
        }

        .replace-mode-indicator span {
            font-weight: bold;
            color: #ff9800;
        }

        /* Control Buttons */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4fc3f7, #29b6f6);
            color: #1a1a2e;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 195, 247, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #66bb6a, #43a047);
            color: #fff;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 187, 106, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef5350, #e53935);
            color: #fff;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(239, 83, 80, 0.4);
        }

        .btn-cancel {
            background: linear-gradient(135deg, #78909c, #546e7a);
            color: #fff;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Pick Mode Indicator */
        .pick-mode-indicator {
            display: none;
            text-align: center;
            padding: 15px;
            background: rgba(102, 187, 106, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #66bb6a;
        }

        .pick-mode-indicator.active {
            display: block;
        }

        .pick-mode-indicator span {
            font-weight: bold;
            color: #66bb6a;
        }

        /* Equipment Filters */
        .equipment-filters {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .equipment-filters .filter-label {
            color: #90a4ae;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .equipment-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .equipment-toggle:hover {
            background: rgba(79, 195, 247, 0.1);
        }

        .equipment-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #4fc3f7;
        }

        .equipment-toggle .toggle-text {
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .equipment-toggle input:not(:checked) + .toggle-text {
            color: #78909c;
            text-decoration: line-through;
        }

        /* Exercise Library */
        .exercise-library {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .exercise-library h2 {
            text-align: center;
            color: #4fc3f7;
            margin-bottom: 20px;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .categories-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .category {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .category-header {
            background: linear-gradient(135deg, #37474f, #263238);
            padding: 12px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .category-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: #4fc3f7;
        }

        .category-controls {
            display: flex;
            gap: 5px;
        }

        .category-controls button {
            padding: 4px 8px;
            font-size: 0.7rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            transition: background 0.2s;
        }

        .category-controls button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .category-exercises {
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .exercise-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            margin-bottom: 5px;
            transition: all 0.2s ease;
            cursor: default;
        }

        .exercise-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .exercise-item.disabled {
            opacity: 0.4;
        }

        .exercise-item.pick-mode {
            cursor: pointer;
        }

        .exercise-item.pick-mode:hover {
            background: rgba(102, 187, 106, 0.2);
        }

        .exercise-item.selected-pick {
            background: rgba(102, 187, 106, 0.3);
            border: 1px solid #66bb6a;
        }

        .exercise-item .toggle {
            position: relative;
            width: 36px;
            height: 20px;
            margin-right: 10px;
            flex-shrink: 0;
        }

        .exercise-item .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .exercise-item .toggle .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #37474f;
            transition: 0.3s;
            border-radius: 20px;
        }

        .exercise-item .toggle .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: #90a4ae;
            transition: 0.3s;
            border-radius: 50%;
        }

        .exercise-item .toggle input:checked + .slider {
            background-color: #4fc3f7;
        }

        .exercise-item .toggle input:checked + .slider:before {
            transform: translateX(16px);
            background-color: #fff;
        }

        .exercise-item .exercise-label {
            flex: 1;
            font-size: 0.9rem;
            color: #e0e0e0;
        }

        .exercise-item .exercise-label a {
            color: #4fc3f7;
            text-decoration: none;
            transition: color 0.2s;
        }

        .exercise-item .exercise-label a:hover {
            color: #81d4fa;
            text-decoration: underline;
        }

        .exercise-item .exercise-label .video-icon {
            font-size: 0.75em;
            margin-left: 4px;
        }

        /* Warning message */
        .warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
            color: #ffc107;
            display: none;
        }

        .warning.visible {
            display: block;
        }

        /* Loading state */
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2rem;
            color: #90a4ae;
        }

        .loading::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(79, 195, 247, 0.3);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(79, 195, 247, 0.5);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            .exercise-slots {
                grid-template-columns: 1fr;
            }

            .categories-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Animation for random selection */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .exercise-slot.animating {
            animation: pulse 0.3s ease;
        }

        /* ==================== TABATA TIMER STYLES ==================== */

        /* Timer Settings Panel */
        .timer-settings {
            background: linear-gradient(145deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 16px;
            padding: 20px 25px;
            margin-bottom: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(79, 195, 247, 0.2);
        }

        .timer-settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            margin-top: 15px;
            margin-bottom: 15px;
        }

        .timer-settings-header h3 {
            color: #4fc3f7;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 0;
        }

        .timer-settings-toggle {
            color: #4fc3f7;
            font-size: 1.2rem;
            transition: transform 0.3s;
        }

        .timer-settings.collapsed .timer-settings-toggle {
            transform: rotate(-90deg);
        }

        .timer-settings.collapsed .timer-settings-content {
            display: none;
        }

        .timer-settings-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .setting-group {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        .setting-group label {
            display: block;
            color: #90a4ae;
            font-size: 0.85rem;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-group input[type="number"] {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-size: 1.1rem;
            text-align: center;
        }

        .setting-group input[type="number"]:focus {
            outline: none;
            border-color: #4fc3f7;
            box-shadow: 0 0 10px rgba(79, 195, 247, 0.3);
        }

        .timer-summary {
            text-align: center;
            padding: 15px;
            background: rgba(79, 195, 247, 0.1);
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .timer-summary .total-time {
            font-size: 1.5rem;
            font-weight: bold;
            color: #4fc3f7;
        }

        .timer-summary .total-label {
            font-size: 0.85rem;
            color: #90a4ae;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sound-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .sound-toggle label {
            color: #e0e0e0;
            cursor: pointer;
        }

        .btn-start-timer {
            background: linear-gradient(135deg, #ff6b35, #f7931e);
            color: #fff;
            width: 100%;
            padding: 16px;
            font-size: 1.2rem;
        }

        .btn-start-timer:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
        }

        .btn-start-timer:disabled {
            background: linear-gradient(135deg, #546e7a, #37474f);
            cursor: not-allowed;
        }

        .btn-mega-move {
            background: linear-gradient(135deg, #9c27b0, #673ab7);
            color: #fff;
            width: 100%;
            padding: 16px;
            font-size: 1.2rem;
            margin-top: 10px;
        }

        .btn-mega-move:hover {
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.4);
        }

        /* Timer Overlay */
        .timer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            display: none;
            flex-direction: column;
            transition: background 0.5s ease;
        }

        .timer-overlay.active {
            display: flex;
        }

        .timer-overlay.exercise-phase {
            background: linear-gradient(135deg, #2e7d32 0%, #1b5e20 100%);
        }

        .timer-overlay.rest-phase {
            background: linear-gradient(135deg, #1976d2 0%, #0d47a1 100%);
        }

        .timer-overlay.cycle-rest-phase {
            background: linear-gradient(135deg, #7b1fa2 0%, #4a148c 100%);
        }

        .timer-overlay.countdown-phase {
            background: linear-gradient(135deg, #f9a825 0%, #f57f17 100%);
        }

        .timer-overlay.complete-phase {
            background: linear-gradient(135deg, #388e3c 0%, #1b5e20 100%);
        }

        /* Timer Header */
        .timer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: rgba(0, 0, 0, 0.2);
        }

        .timer-progress-info {
            display: flex;
            gap: 30px;
        }

        .progress-item {
            text-align: center;
        }

        .progress-item .label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .progress-item .value {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .timer-total-remaining {
            text-align: right;
        }

        .timer-total-remaining .label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .timer-total-remaining .value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* Timer Main Content */
        .timer-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .timer-phase-label {
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0.9;
            margin-bottom: 10px;
        }

        .timer-exercise-name {
            font-size: 3.5rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 90%;
            line-height: 1.2;
        }

        .timer-countdown-container {
            position: relative;
            width: 280px;
            height: 280px;
            margin-bottom: 30px;
        }

        .timer-countdown-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .timer-countdown-ring svg {
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
        }

        .timer-countdown-ring .ring-bg {
            fill: none;
            stroke: rgba(255, 255, 255, 0.2);
            stroke-width: 12;
        }

        .timer-countdown-ring .ring-progress {
            fill: none;
            stroke: #fff;
            stroke-width: 12;
            stroke-linecap: round;
            transition: stroke-dashoffset 0.1s linear;
        }

        .timer-countdown-number {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .timer-next-up {
            text-align: center;
            opacity: 0.8;
        }

        .timer-next-up .label {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .timer-next-up .exercise {
            font-size: 2.2rem;
            font-weight: 600;
        }

        /* Timer Controls */
        .timer-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px 30px 40px;
            background: rgba(0, 0, 0, 0.2);
        }

        .timer-btn {
            width: 60px;
            height: 60px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .timer-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .timer-btn.primary {
            width: 80px;
            height: 80px;
            font-size: 2rem;
            background: rgba(255, 255, 255, 0.3);
        }

        .timer-btn.stop {
            background: rgba(239, 83, 80, 0.6);
        }

        .timer-btn.stop:hover {
            background: rgba(239, 83, 80, 0.8);
        }

        /* Timer Complete Screen */
        .timer-complete {
            text-align: center;
        }

        .timer-complete-icon {
            font-size: 6rem;
            margin-bottom: 20px;
        }

        .timer-complete-message {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 30px;
        }

        .timer-complete-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-bottom: 40px;
        }

        .timer-complete-stat {
            text-align: center;
        }

        .timer-complete-stat .value {
            font-size: 2.5rem;
            font-weight: bold;
        }

        .timer-complete-stat .label {
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        /* Responsive Timer */
        @media (max-width: 768px) {
            .timer-exercise-name {
                font-size: 2.5rem;
            }

            .timer-countdown-container {
                width: 220px;
                height: 220px;
            }

            .timer-countdown-number {
                font-size: 5rem;
            }

            .timer-header {
                flex-direction: column;
                gap: 15px;
            }

            .timer-progress-info {
                gap: 20px;
            }

            .timer-total-remaining {
                text-align: center;
            }
        }

        /* Pulse animation for countdown warning */
        @keyframes pulse-warning {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.15); opacity: 1; }
        }

        .timer-countdown-number.warning {
            display: block !important;
            animation: pulse-warning 0.5s ease infinite;
            color: #ff5722 !important;
            text-shadow: 0 0 30px rgba(255, 87, 34, 0.8), 0 4px 20px rgba(0, 0, 0, 0.5) !important;
            will-change: transform;
        }

        /* Paused indicator */
        .timer-paused-indicator {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 15px;
            z-index: 100;
            text-align: center;
        }

        .timer-paused-indicator.active {
            display: block;
        }

        .timer-paused-indicator .paused-text {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffeb3b;
            text-transform: uppercase;
            letter-spacing: 4px;
        }

        .timer-paused-indicator .paused-hint {
            font-size: 1rem;
            color: #fff;
            margin-top: 10px;
            opacity: 0.8;
        }

        /* ==================== MOBILE RESPONSIVE STYLES ==================== */

        /* Prevent iOS zoom on input focus */
        input[type="number"] {
            font-size: 16px !important;
        }

        /* Mobile styles for screens under 600px */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            /* Selected exercises - single column on mobile */
            .selected-exercises {
                padding: 15px;
                margin-bottom: 15px;
            }

            .selected-exercises h2 {
                font-size: 1rem;
                margin-bottom: 15px;
            }

            .exercise-slots {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .exercise-slot {
                padding: 12px 15px;
            }

            .exercise-slot .number {
                width: 28px;
                height: 28px;
                font-size: 0.9rem;
            }

            .exercise-slot .exercise-name {
                font-size: 1rem;
            }

            .exercise-slot .exercise-category {
                font-size: 0.75rem;
            }

            .exercise-slot .slot-actions {
                gap: 8px;
            }

            .exercise-slot .slot-btn {
                width: 36px;
                height: 36px;
                font-size: 1rem;
            }

            /* Control buttons - stack on mobile */
            .controls {
                flex-direction: column;
                gap: 10px;
                margin-bottom: 20px;
            }

            .btn {
                padding: 14px 20px;
                font-size: 1rem;
                width: 100%;
            }

            /* Timer settings panel */
            .timer-settings {
                padding: 15px;
                margin-bottom: 15px;
            }

            .timer-settings-header h3 {
                font-size: 0.95rem;
            }

            .timer-settings-content {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .setting-group {
                padding: 12px;
            }

            .setting-group label {
                font-size: 0.7rem;
                margin-bottom: 6px;
            }

            .setting-group input[type="number"] {
                padding: 10px 8px;
                font-size: 16px !important;
            }

            .timer-summary {
                padding: 12px;
                margin-bottom: 12px;
            }

            .timer-summary .total-time {
                font-size: 1.3rem;
            }

            .btn-start-timer {
                padding: 14px;
                font-size: 1.1rem;
            }

            .btn-mega-move {
                padding: 14px;
                font-size: 1.1rem;
            }

            /* Exercise library */
            .exercise-library h2 {
                font-size: 1.1rem;
            }

            .global-controls {
                margin-bottom: 15px;
            }

            .global-controls .btn {
                width: auto;
                padding: 10px 15px;
                font-size: 0.85rem;
            }

            .categories-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .category-card {
                padding: 12px;
            }

            .category-card h3 {
                font-size: 0.95rem;
            }

            /* Timer overlay mobile */
            .timer-header {
                padding: 12px 15px;
            }

            .timer-progress-info {
                gap: 15px;
            }

            .progress-item .label {
                font-size: 0.65rem;
            }

            .progress-item .value {
                font-size: 1.1rem;
            }

            .timer-total-remaining .label {
                font-size: 0.65rem;
            }

            .timer-total-remaining .value {
                font-size: 1.2rem;
            }

            .timer-main {
                padding: 15px;
            }

            .timer-phase-label {
                font-size: 1.1rem;
                letter-spacing: 2px;
            }

            .timer-exercise-name {
                font-size: 2.4rem;
                margin-bottom: 20px;
                font-weight: bold;
            }

            .timer-countdown-container {
                width: 180px;
                height: 180px;
                margin-bottom: 20px;
            }

            .timer-countdown-number {
                font-size: 4.5rem;
            }

            .timer-next-up .label {
                font-size: 0.9rem;
            }

            .timer-next-up .exercise {
                font-size: 1.8rem;
                font-weight: 600;
            }

            .timer-controls {
                padding: 15px 20px 25px;
                gap: 15px;
            }

            .timer-btn {
                width: 50px;
                height: 50px;
                font-size: 1.3rem;
            }

            .timer-btn.primary {
                width: 65px;
                height: 65px;
                font-size: 1.6rem;
            }

            /* Paused indicator mobile */
            .timer-paused-indicator {
                padding: 15px 25px;
            }

            .timer-paused-indicator .paused-text {
                font-size: 1.8rem;
                letter-spacing: 2px;
            }

            .timer-paused-indicator .paused-hint {
                font-size: 0.85rem;
            }

            /* Complete screen mobile */
            .timer-complete-icon {
                font-size: 4rem;
            }

            .timer-complete-message {
                font-size: 1.8rem;
                margin-bottom: 20px;
            }

            .timer-complete-stats {
                flex-direction: column;
                gap: 15px;
            }

            .timer-complete-stat .value {
                font-size: 2rem;
            }

            .timer-complete-stat .label {
                font-size: 0.8rem;
            }

            /* Replace mode indicator */
            .replace-mode-indicator {
                padding: 12px;
                font-size: 0.9rem;
            }
        }

        /* Extra small screens (under 380px) */
        @media (max-width: 380px) {
            h1 {
                font-size: 1.3rem;
            }

            .timer-settings-content {
                grid-template-columns: 1fr;
            }

            .timer-exercise-name {
                font-size: 2rem;
                font-weight: bold;
            }

            .timer-countdown-container {
                width: 150px;
                height: 150px;
            }

            .timer-countdown-number {
                font-size: 3.5rem;
            }

            .timer-next-up .exercise {
                font-size: 1.6rem;
            }
        }

        /* Touch-friendly tap targets */
        @media (hover: none) and (pointer: coarse) {
            .exercise-slot .slot-btn {
                min-width: 44px;
                min-height: 44px;
            }

            .timer-btn {
                min-width: 54px;
                min-height: 54px;
            }

            .timer-btn.primary {
                min-width: 70px;
                min-height: 70px;
            }

            .btn {
                min-height: 48px;
            }

            /* Larger checkbox area */
            .toggle-label {
                padding: 8px 0;
            }
        }

        /* Disclaimer Footer */
        .disclaimer-footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #78909c;
            font-size: 0.75rem;
            line-height: 1.5;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* ==================== EXERCISE INFO MODAL ==================== */
        .exercise-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .exercise-modal-overlay.active {
            display: flex;
        }

        .exercise-modal {
            background: linear-gradient(145deg, #1e3a5f 0%, #0d2137 100%);
            border-radius: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(79, 195, 247, 0.3);
        }

        .exercise-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .exercise-modal-header h3 {
            color: #4fc3f7;
            font-size: 1.4rem;
            margin: 0;
        }

        .exercise-modal-close {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .exercise-modal-close:hover {
            background: rgba(239, 83, 80, 0.3);
            color: #ef5350;
        }

        .exercise-modal-body {
            padding: 25px;
        }

        .exercise-animation-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-bottom: 25px;
        }

        .exercise-animation {
            width: 150px;
            height: 120px;
            color: #4fc3f7;
        }

        .exercise-tips {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .exercise-tips li {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            color: #e0e0e0;
            font-size: 1rem;
            line-height: 1.5;
        }

        .exercise-tips li:last-child {
            border-bottom: none;
        }

        .exercise-tips li::before {
            content: "üí°";
            flex-shrink: 0;
        }

        .exercise-modal-footer {
            padding: 15px 25px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .exercise-modal-footer a {
            color: #4fc3f7;
            text-decoration: none;
            font-size: 0.9rem;
        }

        .exercise-modal-footer a:hover {
            text-decoration: underline;
        }

        /* Info button for exercises */
        .exercise-info-btn {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 50%;
            background: rgba(79, 195, 247, 0.2);
            color: #4fc3f7;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            flex-shrink: 0;
        }

        .exercise-info-btn:hover {
            background: rgba(79, 195, 247, 0.4);
            transform: scale(1.1);
        }

        /* Mobile adjustments for modal */
        @media (max-width: 600px) {
            .exercise-modal {
                max-height: 85vh;
                margin: 10px;
            }

            .exercise-modal-header h3 {
                font-size: 1.2rem;
            }

            .exercise-animation {
                width: 120px;
                height: 100px;
            }

            .exercise-tips li {
                font-size: 0.95rem;
            }
        }
    </style>
    <script src="exercise-reference.js"></script>
</head>
<body>
    <div class="container">
        <h1>üèãÔ∏è Tabata Exercise Selector</h1>
        <div style="text-align: center; margin-bottom: 20px;">
            <a href="exercise-guide.html" style="color: #4fc3f7; text-decoration: none; font-size: 0.95rem;">üìñ Exercise Reference Guide</a>
        </div>

        <!-- Selected Exercises Display -->
        <div class="selected-exercises">
            <h2>Selected Exercises (6)</h2>
            <div class="exercise-slots" id="exerciseSlots">
                <!-- Slots will be generated by JS -->
            </div>
        </div>

        <!-- Warning Message -->
        <div class="warning" id="warningMessage"></div>

        <!-- Pick Mode Indicator -->
        <div class="pick-mode-indicator" id="pickModeIndicator">
            üéØ Pick Mode Active - <span id="pickCount">0</span>/6 selected. Click exercises below to select them.
        </div>

        <!-- Replace Mode Indicator -->
        <div class="replace-mode-indicator" id="replaceModeIndicator">
            üîÑ Replace Mode - Click an exercise below to replace slot <span id="replaceSlotNum">1</span>.
        </div>

        <!-- Control Buttons -->
        <div class="controls">
            <button class="btn btn-primary" id="randomBtn" onclick="randomSelect()">
                üé≤ Random 6
            </button>
            <button class="btn btn-secondary" id="pickBtn" onclick="togglePickMode()">
                ‚úã Pick 6
            </button>
            <button class="btn btn-cancel" id="cancelPickBtn" onclick="cancelPickMode()" style="display: none;">
                ‚ùå Cancel
            </button>
            <button class="btn btn-danger" id="clearBtn" onclick="clearSelection()">
                üóëÔ∏è Clear
            </button>
        </div>

        <!-- Timer Settings Panel -->
        <div class="timer-settings" id="timerSettings">
            <button class="btn btn-start-timer" id="startTimerBtn" onclick="startTimer()" disabled>
                ‚ñ∂Ô∏è Start Workout
            </button>
            <button class="btn btn-mega-move" id="megaMoveBtn" onclick="startMegaMoveCircuit()">
                üîÄ Start Mega Random Tabata
            </button>
            <div class="timer-summary">
                <div class="total-label">Total Workout Time</div>
                <div class="total-time" id="totalWorkoutTime">--:--</div>
            </div>
            <div class="timer-settings-header" onclick="toggleTimerSettings()">
                <h3>‚öôÔ∏è Timer Settings</h3>
                <span class="timer-settings-toggle">‚ñº</span>
            </div>
            <div class="timer-settings-content">
                <div class="setting-group">
                    <label>Exercise Duration (sec)</label>
                    <input type="number" id="exerciseDuration" value="30" min="5" max="120" onchange="updateTimerSummary()">
                </div>
                <div class="setting-group">
                    <label>Rest Between Exercises (sec)</label>
                    <input type="number" id="restDuration" value="15" min="5" max="60" onchange="updateTimerSummary()">
                </div>
                <div class="setting-group">
                    <label>Rest Between Cycles (sec)</label>
                    <input type="number" id="cycleRestDuration" value="30" min="10" max="120" onchange="updateTimerSummary()">
                </div>
                <div class="setting-group">
                    <label>Number of Cycles</label>
                    <input type="number" id="numCycles" value="5" min="1" max="10" onchange="updateTimerSummary()">
                </div>
                <div class="setting-group">
                    <label>Get Ready Countdown (sec)</label>
                    <input type="number" id="countdownDuration" value="15" min="3" max="30" onchange="updateTimerSummary()">
                </div>
            </div>
            <div class="sound-toggle">
                <label class="toggle">
                    <input type="checkbox" id="soundEnabled" checked>
                    <span class="slider"></span>
                </label>
                <label for="soundEnabled">üîä Sound Effects</label>
            </div>
        </div>

        <!-- Exercise Library -->
        <div class="exercise-library">
            <h2>Exercise Library</h2>

            <div class="equipment-filters">
                <span class="filter-label">Equipment:</span>
                <label class="equipment-toggle">
                    <input type="checkbox" id="filterYogaBall" checked onchange="applyEquipmentFilters()">
                    <span class="toggle-text">Yoga Ball</span>
                </label>
                <label class="equipment-toggle">
                    <input type="checkbox" id="filterWeights" checked onchange="applyEquipmentFilters()">
                    <span class="toggle-text">Dumbbells/Kettlebells</span>
                </label>
                <label class="equipment-toggle">
                    <input type="checkbox" id="filterGym" checked onchange="applyEquipmentFilters()">
                    <span class="toggle-text">Gym/Space Required</span>
                </label>
            </div>

            <div class="categories-grid" id="categoriesGrid">
                <div class="loading">Loading exercises</div>
            </div>
        </div>
    </div>

    <!-- Timer Overlay -->
    <div class="timer-overlay" id="timerOverlay">
        <div class="timer-header">
            <div class="timer-progress-info">
                <div class="progress-item">
                    <div class="label">Exercise</div>
                    <div class="value"><span id="timerCurrentExercise">1</span> / 6</div>
                </div>
                <div class="progress-item">
                    <div class="label">Cycle</div>
                    <div class="value"><span id="timerCurrentCycle">1</span> / <span id="timerTotalCycles">5</span></div>
                </div>
            </div>
            <div class="timer-total-remaining">
                <div class="label">Total Remaining</div>
                <div class="value" id="timerTotalRemaining">--:--</div>
            </div>
        </div>

        <div class="timer-main" id="timerMain">
            <div class="timer-phase-label" id="timerPhaseLabel">GET READY</div>
            <div class="timer-exercise-name" id="timerExerciseName">Starting...</div>

            <div class="timer-countdown-container">
                <div class="timer-countdown-ring">
                    <svg viewBox="0 0 100 100">
                        <circle class="ring-bg" cx="50" cy="50" r="44"></circle>
                        <circle class="ring-progress" id="timerRingProgress" cx="50" cy="50" r="44"
                                stroke-dasharray="276.46" stroke-dashoffset="0"></circle>
                    </svg>
                </div>
                <div class="timer-countdown-number" id="timerCountdown">0</div>
            </div>

            <div class="timer-next-up" id="timerNextUp">
                <div class="label">Next Up</div>
                <div class="exercise" id="timerNextExercise">--</div>
            </div>
        </div>

        <!-- Paused indicator overlay -->
        <div class="timer-paused-indicator" id="timerPausedIndicator">
            <div class="paused-text">PAUSED</div>
            <div class="paused-hint">Press Space to resume</div>
        </div>

        <div class="timer-controls">
            <button class="timer-btn" onclick="skipBack()" title="Previous (Left Arrow)">‚èÆÔ∏è</button>
            <button class="timer-btn primary" id="timerPauseBtn" onclick="togglePause()" title="Pause/Resume (Space)">‚è∏Ô∏è</button>
            <button class="timer-btn" onclick="skipForward()" title="Next (Right Arrow)">‚è≠Ô∏è</button>
            <button class="timer-btn stop" onclick="stopTimer()" title="Stop (Escape)">‚èπÔ∏è</button>
        </div>
    </div>

    <script>
        // Global state
        let exerciseData = {}; // { categoryName: [{name, link}, ...] }
        let toggleStates = {}; // { "category|exercise": true/false }
        let selectedExercises = []; // [{name, category, link}, ...]
        let pickMode = false;
        let pickedExercises = []; // Temporary during pick mode
        let replaceMode = false;
        let replaceSlotIndex = -1; // Which slot is being replaced
        let selectionMode = 'random'; // 'random' or 'pick' - how exercises were selected
        let megaMoveMode = false; // For mega move circuit - random exercise each interval
        let megaMoveExercisePool = []; // Pool of enabled exercises for mega move
        let currentMegaMoveExercise = null; // Current exercise in mega move mode
        let nextMegaMoveExercise = null; // Next exercise in mega move mode (for preview)

        // Initialize the app
        async function init() {
            await loadExerciseData();
            loadToggleStates();
            renderCategories();
            renderSelectedExercises();
        }

        // Load and parse Excel file
        async function loadExerciseData() {
            try {
                const response = await fetch('Tabata.xlsx');
                const arrayBuffer = await response.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });

                const sheetName = workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetName];

                // Get the range of the sheet
                const range = XLSX.utils.decode_range(sheet['!ref']);

                // Extract categories from row 1
                const categories = [];
                for (let col = range.s.c; col <= range.e.c; col++) {
                    const cellAddress = XLSX.utils.encode_cell({ r: 0, c: col });
                    const cell = sheet[cellAddress];
                    if (cell && cell.v && typeof cell.v === 'string' && cell.v.trim()) {
                        categories.push({ name: cell.v.trim(), col: col });
                    }
                }

                // Extract exercises for each category
                categories.forEach(cat => {
                    exerciseData[cat.name] = [];

                    for (let row = 1; row <= range.e.r; row++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: cat.col });
                        const cell = sheet[cellAddress];

                        if (cell && cell.v) {
                            let exerciseName = String(cell.v).trim();

                            // Skip empty, placeholder, or invalid entries
                            if (!exerciseName ||
                                exerciseName === '...' ||
                                exerciseName === '..' ||
                                exerciseName === '.' ||
                                exerciseName.length < 2) {
                                continue;
                            }

                            // Skip entries that are just URLs (not exercise names)
                            if (exerciseName.startsWith('http://') ||
                                exerciseName.startsWith('https://') ||
                                exerciseName.startsWith('www.')) {
                                continue;
                            }

                            // Clean up exercise names - remove parenthetical notes like "(what kevin does)"
                            exerciseName = exerciseName
                                .replace(/\s*\(what kevin does\)\s*/gi, '')
                                .replace(/\s*\(what Kevin does\)\s*/gi, '')
                                .trim();

                            // Fix common spelling mistakes
                            const spellingFixes = {
                                'hamsting curls': 'Hamstring Curls',
                                'hamstring curl': 'Hamstring Curls',
                                'dumbell': 'Dumbbell',
                                'dumbel ': 'Dumbbell ',
                                'excercise': 'Exercise',
                                'excersize': 'Exercise',
                                'plank jacks': 'Plank Jacks',
                                'mountian climbers': 'Mountain Climbers',
                                'moutain climbers': 'Mountain Climbers'
                            };

                            // Apply spelling fixes (case-insensitive)
                            Object.keys(spellingFixes).forEach(wrong => {
                                const regex = new RegExp(wrong, 'gi');
                                exerciseName = exerciseName.replace(regex, spellingFixes[wrong]);
                            });

                            // Check for hyperlink
                            let link = null;
                            if (cell.l && cell.l.Target) {
                                link = cell.l.Target;
                            }

                            exerciseData[cat.name].push({
                                name: exerciseName,
                                link: link
                            });
                        }
                    }
                });

                // Remove Table Dip from all categories
                Object.keys(exerciseData).forEach(category => {
                    exerciseData[category] = exerciseData[category].filter(ex =>
                        !ex.name.toLowerCase().includes('table dip')
                    );
                });

                // Create Total Body category with specific exercises
                const totalBodyExercises = ['burpees', 'marky marks', 'mark-e-mark', 'bear crawl', 'copenhagen'];
                exerciseData['Total Body'] = [];

                // Find and copy exercises to Total Body (they stay in original categories too)
                Object.keys(exerciseData).forEach(category => {
                    if (category === 'Total Body') return;
                    exerciseData[category].forEach(exercise => {
                        const nameLower = exercise.name.toLowerCase();
                        if (totalBodyExercises.some(tb => nameLower.includes(tb))) {
                            // Check if not already added
                            if (!exerciseData['Total Body'].some(e => e.name.toLowerCase() === nameLower)) {
                                exerciseData['Total Body'].push({ ...exercise });
                            }
                        }
                    });
                });

                // Add Burpees to Total Body if not found in data
                if (!exerciseData['Total Body'].some(e => e.name.toLowerCase() === 'burpees')) {
                    exerciseData['Total Body'].unshift({ name: 'Burpees', link: null });
                }

                // Also ensure Burpees is in Cardio
                if (exerciseData['Cardio'] && !exerciseData['Cardio'].some(ex => ex.name.toLowerCase() === 'burpees')) {
                    exerciseData['Cardio'].unshift({ name: 'Burpees', link: null });
                }

                console.log('Loaded exercise data:', exerciseData);
            } catch (error) {
                console.error('Error loading exercise data:', error);
                document.getElementById('categoriesGrid').innerHTML =
                    '<p style="color: #ef5350; text-align: center;">Error loading exercise data. Make sure Tabata.xlsx is in the same directory.</p>';
            }
        }

        // Load toggle states from localStorage
        function loadToggleStates() {
            const saved = localStorage.getItem('exerciseToggleStates');
            if (saved) {
                toggleStates = JSON.parse(saved);
            } else {
                // Exercises to disable by default (case-insensitive matching)
                const defaultDisabled = [
                    'jackknife',
                    'jack knife',
                    'handstand',
                    'dumbbell fly',
                    'dumbell fly',
                    'frog crunch',
                    'balance squat'
                ];

                // Default all to enabled, except specified ones
                Object.keys(exerciseData).forEach(category => {
                    exerciseData[category].forEach(exercise => {
                        const key = `${category}|${exercise.name}`;
                        const exerciseNameLower = exercise.name.toLowerCase();
                        // Check if this exercise should be disabled by default
                        const shouldDisable = defaultDisabled.some(disabled =>
                            exerciseNameLower.includes(disabled.toLowerCase())
                        );
                        toggleStates[key] = !shouldDisable;
                    });
                });
            }
        }

        // Save toggle states to localStorage
        function saveToggleStates() {
            localStorage.setItem('exerciseToggleStates', JSON.stringify(toggleStates));
        }

        // Equipment requirements for exercises
        const equipmentRequirements = {
            yogaBall: [
                'hamstring curls', 'v crunch ball', 'rollout', 'superman\'s balls', 'supermans balls'
            ],
            weights: [
                'dumbbell fly', 'dumbell fly', 'goblet squat', 'dumbbell snatch',
                'front lift', 'marky marks', 'shrugs',
                'renegade row', 'lawnmowers', 'lawnmower'
            ],
            gym: [
                'balance squat', 'box jump', 'slams', 'fly', 'bench', 'monkey crunch',
                'lap', 'run a lap', 'suicide'
            ]
        };

        function getEquipmentType(exerciseName) {
            const nameLower = exerciseName.toLowerCase();
            const types = [];
            if (equipmentRequirements.yogaBall.some(e => nameLower.includes(e))) types.push('yogaBall');
            if (equipmentRequirements.weights.some(e => nameLower.includes(e))) types.push('weights');
            if (equipmentRequirements.gym.some(e => nameLower.includes(e))) types.push('gym');
            return types;
        }

        // Render categories and exercises
        function renderCategories() {
            const grid = document.getElementById('categoriesGrid');
            grid.innerHTML = '';

            // Define category order - Total Body first
            const categoryOrder = ['Total Body', ...Object.keys(exerciseData).filter(c => c !== 'Total Body').sort()];

            categoryOrder.forEach(category => {
                if (!exerciseData[category] || exerciseData[category].length === 0) return;

                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'category';
                categoryDiv.dataset.category = category;
                categoryDiv.innerHTML = `
                    <div class="category-header">
                        <span class="category-name">${category}</span>
                    </div>
                    <div class="category-exercises" id="cat-${category.replace(/\s+/g, '-')}">
                    </div>
                `;
                grid.appendChild(categoryDiv);

                const exercisesDiv = categoryDiv.querySelector('.category-exercises');

                exerciseData[category].forEach(exercise => {
                    const key = `${category}|${exercise.name}`;
                    const isEnabled = toggleStates[key] !== false;
                    const equipTypes = getEquipmentType(exercise.name);

                    const exerciseDiv = document.createElement('div');
                    exerciseDiv.className = `exercise-item ${isEnabled ? '' : 'disabled'}`;
                    exerciseDiv.dataset.category = category;
                    exerciseDiv.dataset.name = exercise.name;
                    exerciseDiv.dataset.link = exercise.link || '';
                    exerciseDiv.dataset.equipment = equipTypes.join(',');

                    let labelContent = exercise.name;
                    if (exercise.link) {
                        labelContent = `<a href="${exercise.link}" target="_blank" rel="noopener">${exercise.name}<span class="video-icon">üé¨</span></a>`;
                    }

                    const escapedName = exercise.name.replace(/'/g, "\\'");
                    const escapedLink = exercise.link ? exercise.link.replace(/'/g, "\\'") : '';

                    exerciseDiv.innerHTML = `
                        <label class="toggle">
                            <input type="checkbox" ${isEnabled ? 'checked' : ''}
                                   onchange="toggleExercise('${category}', '${escapedName}', this.checked)">
                            <span class="slider"></span>
                        </label>
                        <span class="exercise-label">${labelContent}</span>
                        <button class="exercise-info-btn" onclick="event.stopPropagation(); showExerciseInfo('${escapedName}', '${escapedLink}')" title="Exercise Info">‚Ñπ</button>
                    `;

                    exerciseDiv.addEventListener('click', (e) => {
                        if (e.target.closest('.toggle')) return; // Don't interfere with toggle clicks

                        if (replaceMode) {
                            handleReplaceClick(category, exercise.name, exercise.link);
                        } else if (pickMode) {
                            handlePickClick(category, exercise.name, exercise.link, exerciseDiv);
                        }
                    });

                    exercisesDiv.appendChild(exerciseDiv);
                });
            });

            // Apply equipment filters after rendering
            applyEquipmentFilters();
        }

        // Apply equipment filters to hide/show exercises
        function applyEquipmentFilters() {
            const showYogaBall = document.getElementById('filterYogaBall').checked;
            const showWeights = document.getElementById('filterWeights').checked;
            const showGym = document.getElementById('filterGym').checked;

            document.querySelectorAll('.exercise-item').forEach(item => {
                const equipment = item.dataset.equipment || '';
                let shouldHide = false;

                if (equipment.includes('yogaBall') && !showYogaBall) shouldHide = true;
                if (equipment.includes('weights') && !showWeights) shouldHide = true;
                if (equipment.includes('gym') && !showGym) shouldHide = true;

                item.style.display = shouldHide ? 'none' : '';
            });

            // Hide empty categories
            document.querySelectorAll('.category').forEach(cat => {
                const visibleExercises = cat.querySelectorAll('.exercise-item:not([style*="display: none"])');
                cat.style.display = visibleExercises.length === 0 ? 'none' : '';
            });
        }

        // Toggle individual exercise
        function toggleExercise(category, exerciseName, enabled) {
            const key = `${category}|${exerciseName}`;
            toggleStates[key] = enabled;
            saveToggleStates();

            // Update visual state
            const items = document.querySelectorAll('.exercise-item');
            items.forEach(item => {
                if (item.dataset.category === category && item.dataset.name === exerciseName) {
                    item.classList.toggle('disabled', !enabled);
                }
            });
        }

        // Enable all exercises in a category
        function enableCategory(category) {
            exerciseData[category].forEach(exercise => {
                const key = `${category}|${exercise.name}`;
                toggleStates[key] = true;
            });
            saveToggleStates();
            renderCategories();
            updatePickModeState();
        }

        // Disable all exercises in a category
        function disableCategory(category) {
            exerciseData[category].forEach(exercise => {
                const key = `${category}|${exercise.name}`;
                toggleStates[key] = false;
            });
            saveToggleStates();
            renderCategories();
            updatePickModeState();
        }

        // Enable all exercises globally
        function enableAll() {
            Object.keys(exerciseData).forEach(category => {
                exerciseData[category].forEach(exercise => {
                    const key = `${category}|${exercise.name}`;
                    toggleStates[key] = true;
                });
            });
            saveToggleStates();
            renderCategories();
            updatePickModeState();
        }

        // Disable all exercises globally
        function disableAll() {
            Object.keys(exerciseData).forEach(category => {
                exerciseData[category].forEach(exercise => {
                    const key = `${category}|${exercise.name}`;
                    toggleStates[key] = false;
                });
            });
            saveToggleStates();
            renderCategories();
            updatePickModeState();
        }

        // Random selection
        function randomSelect() {
            hideWarning();

            // Get categories with enabled exercises
            const availableCategories = [];
            Object.keys(exerciseData).forEach(category => {
                const enabledExercises = exerciseData[category].filter(ex => {
                    const key = `${category}|${ex.name}`;
                    return toggleStates[key] !== false;
                });
                if (enabledExercises.length > 0) {
                    availableCategories.push({
                        name: category,
                        exercises: enabledExercises
                    });
                }
            });

            if (availableCategories.length === 0) {
                showWarning('No exercises are enabled! Enable some exercises to use random selection.');
                return;
            }

            // Shuffle categories and pick up to 6
            const shuffledCategories = [...availableCategories].sort(() => Math.random() - 0.5);
            const selectedCategories = shuffledCategories.slice(0, 6);

            if (selectedCategories.length < 6) {
                showWarning(`Only ${selectedCategories.length} categories have enabled exercises. Selecting ${selectedCategories.length} exercises.`);
            }

            // Select one random exercise from each selected category
            selectedExercises = selectedCategories.map(cat => {
                const randomIndex = Math.floor(Math.random() * cat.exercises.length);
                const exercise = cat.exercises[randomIndex];
                return {
                    name: exercise.name,
                    category: cat.name,
                    link: exercise.link
                };
            });

            selectionMode = 'random';
            renderSelectedExercises(true);
        }

        // Render selected exercises
        function renderSelectedExercises(animate = false) {
            const slotsContainer = document.getElementById('exerciseSlots');
            slotsContainer.innerHTML = '';

            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                const exercise = selectedExercises[i];

                if (exercise) {
                    slot.className = `exercise-slot filled ${animate ? 'animating' : ''}`;

                    let nameContent = exercise.name;
                    if (exercise.link) {
                        nameContent = `<a href="${exercise.link}" target="_blank" rel="noopener">${exercise.name}</a>`;
                    }

                    // Build action buttons based on selection mode
                    let actionButtons = '';
                    if (selectionMode === 'random') {
                        // Random mode: show refresh (re-randomize) and replace (manual pick) buttons
                        actionButtons = `
                            <div class="slot-actions">
                                <button class="slot-btn refresh-btn" onclick="refreshSlot(${i})" title="Re-randomize this exercise">üîÑ</button>
                                <button class="slot-btn replace-btn" onclick="startReplaceMode(${i})" title="Pick a replacement">‚úã</button>
                            </div>
                        `;
                    } else {
                        // Pick mode: show remove button to deselect
                        actionButtons = `
                            <div class="slot-actions">
                                <button class="slot-btn remove-btn" onclick="removeFromSlot(${i})" title="Remove and pick different">‚úñ</button>
                            </div>
                        `;
                    }

                    slot.innerHTML = `
                        <div class="number">${i + 1}</div>
                        <div class="exercise-info">
                            <div class="exercise-name">${nameContent}</div>
                            <div class="exercise-category">${exercise.category}</div>
                        </div>
                        ${actionButtons}
                    `;

                    if (animate) {
                        slot.style.animationDelay = `${i * 0.1}s`;
                    }
                } else {
                    slot.className = 'exercise-slot empty';
                    slot.innerHTML = `
                        <div class="number">${i + 1}</div>
                        <div class="exercise-info">
                            <div class="exercise-name">Empty slot</div>
                        </div>
                    `;
                }

                slotsContainer.appendChild(slot);
            }
        }

        // Refresh a single slot with a new random exercise from a different category
        function refreshSlot(slotIndex) {
            hideWarning();

            const currentExercise = selectedExercises[slotIndex];
            if (!currentExercise) return;

            // Get categories that are not already selected (except the one being replaced)
            const usedCategories = selectedExercises
                .filter((ex, idx) => ex && idx !== slotIndex)
                .map(ex => ex.category);

            // Get available categories with enabled exercises
            const availableCategories = [];
            Object.keys(exerciseData).forEach(category => {
                if (usedCategories.includes(category)) return; // Skip already used categories

                const enabledExercises = exerciseData[category].filter(ex => {
                    const key = `${category}|${ex.name}`;
                    return toggleStates[key] !== false;
                });
                if (enabledExercises.length > 0) {
                    availableCategories.push({
                        name: category,
                        exercises: enabledExercises
                    });
                }
            });

            if (availableCategories.length === 0) {
                showWarning('No other categories available for replacement.');
                return;
            }

            // Pick a random category and exercise
            const randomCatIndex = Math.floor(Math.random() * availableCategories.length);
            const selectedCat = availableCategories[randomCatIndex];
            const randomExIndex = Math.floor(Math.random() * selectedCat.exercises.length);
            const newExercise = selectedCat.exercises[randomExIndex];

            selectedExercises[slotIndex] = {
                name: newExercise.name,
                category: selectedCat.name,
                link: newExercise.link
            };

            renderSelectedExercises();
        }

        // Start replace mode - user will click an exercise to replace the slot
        function startReplaceMode(slotIndex) {
            replaceMode = true;
            replaceSlotIndex = slotIndex;

            document.getElementById('replaceModeIndicator').classList.add('active');
            document.getElementById('replaceSlotNum').textContent = slotIndex + 1;
            document.getElementById('randomBtn').disabled = true;
            document.getElementById('pickBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            // Add visual mode to exercise items
            document.querySelectorAll('.exercise-item').forEach(item => {
                item.classList.add('pick-mode');
            });
        }

        // Cancel replace mode
        function cancelReplaceMode() {
            replaceMode = false;
            replaceSlotIndex = -1;

            document.getElementById('replaceModeIndicator').classList.remove('active');
            document.getElementById('randomBtn').disabled = false;
            document.getElementById('pickBtn').disabled = false;
            document.getElementById('clearBtn').disabled = false;

            document.querySelectorAll('.exercise-item').forEach(item => {
                item.classList.remove('pick-mode');
            });
        }

        // Remove exercise from slot (for pick mode) and enter replace mode
        function removeFromSlot(slotIndex) {
            replaceMode = true;
            replaceSlotIndex = slotIndex;

            // Temporarily remove the exercise
            selectedExercises[slotIndex] = null;

            document.getElementById('replaceModeIndicator').classList.add('active');
            document.getElementById('replaceSlotNum').textContent = slotIndex + 1;
            document.getElementById('randomBtn').disabled = true;
            document.getElementById('pickBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            // Add visual mode to exercise items
            document.querySelectorAll('.exercise-item').forEach(item => {
                item.classList.add('pick-mode');
            });

            renderSelectedExercises();
        }

        // Clear selection
        function clearSelection() {
            selectedExercises = [];
            renderSelectedExercises();
            hideWarning();
        }

        // Toggle pick mode
        function togglePickMode() {
            pickMode = true;
            pickedExercises = [];

            document.getElementById('pickModeIndicator').classList.add('active');
            document.getElementById('pickBtn').style.display = 'none';
            document.getElementById('cancelPickBtn').style.display = 'inline-flex';
            document.getElementById('randomBtn').disabled = true;
            document.getElementById('clearBtn').disabled = true;

            updatePickModeState();
            updatePickCount();
        }

        // Update pick mode visual state
        function updatePickModeState() {
            document.querySelectorAll('.exercise-item').forEach(item => {
                if (pickMode) {
                    item.classList.add('pick-mode');
                } else {
                    item.classList.remove('pick-mode');
                    item.classList.remove('selected-pick');
                }
            });
        }

        // Cancel pick mode
        function cancelPickMode() {
            pickMode = false;
            pickedExercises = [];

            document.getElementById('pickModeIndicator').classList.remove('active');
            document.getElementById('pickBtn').style.display = 'inline-flex';
            document.getElementById('cancelPickBtn').style.display = 'none';
            document.getElementById('randomBtn').disabled = false;
            document.getElementById('clearBtn').disabled = false;

            updatePickModeState();
        }

        // Handle click on exercise during pick mode
        function handlePickClick(category, exerciseName, link, element) {
            if (!pickMode) return;

            // Check if already picked
            const existingIndex = pickedExercises.findIndex(
                ex => ex.category === category && ex.name === exerciseName
            );

            if (existingIndex >= 0) {
                // Remove from picked
                pickedExercises.splice(existingIndex, 1);
                element.classList.remove('selected-pick');
            } else if (pickedExercises.length < 6) {
                // Add to picked
                pickedExercises.push({
                    name: exerciseName,
                    category: category,
                    link: link || null
                });
                element.classList.add('selected-pick');
            }

            updatePickCount();

            // Check if we have 6
            if (pickedExercises.length === 6) {
                selectedExercises = [...pickedExercises];
                selectionMode = 'pick';
                cancelPickMode();
                renderSelectedExercises(true);
            }
        }

        // Handle click on exercise during replace mode
        function handleReplaceClick(category, exerciseName, link) {
            if (!replaceMode || replaceSlotIndex < 0) return;

            // Check if this exercise is already selected in another slot
            const alreadySelectedIndex = selectedExercises.findIndex(
                (ex, idx) => ex && idx !== replaceSlotIndex && ex.category === category && ex.name === exerciseName
            );

            if (alreadySelectedIndex >= 0) {
                showWarning('This exercise is already selected in another slot.');
                return;
            }

            // Replace the exercise in the slot
            selectedExercises[replaceSlotIndex] = {
                name: exerciseName,
                category: category,
                link: link || null
            };

            cancelReplaceMode();
            renderSelectedExercises();
            hideWarning();
        }

        // Update pick count display
        function updatePickCount() {
            document.getElementById('pickCount').textContent = pickedExercises.length;
        }

        // Show warning message
        function showWarning(message) {
            const warning = document.getElementById('warningMessage');
            warning.textContent = '‚ö†Ô∏è ' + message;
            warning.classList.add('visible');
        }

        // Hide warning message
        function hideWarning() {
            document.getElementById('warningMessage').classList.remove('visible');
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', init);

        // ==================== TABATA TIMER ====================

        // Timer state
        let timerState = {
            isRunning: false,
            isPaused: false,
            currentCycle: 1,
            currentExerciseIndex: 0,
            currentPhase: 'idle', // 'countdown', 'exercise', 'rest', 'cycleRest', 'complete'
            secondsRemaining: 0,
            phaseDuration: 0,
            totalSecondsRemaining: 0,
            intervalId: null,
            wakeLock: null
        };

        // Timer settings
        let timerSettings = {
            exerciseDuration: 30,
            restDuration: 15,
            cycleRestDuration: 30,
            numCycles: 5,
            countdownDuration: 15
        };

        // Audio context for Web Audio API
        let audioContext = null;

        // Initialize audio context (must be triggered by user interaction)
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Generate a beep sound
        function playBeep(frequency = 800, duration = 0.15, type = 'sine', volume = 0.8) {
            if (!document.getElementById('soundEnabled').checked) return;
            try {
                initAudio();

                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.value = frequency;
                oscillator.type = type;

                gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.warn('Audio playback error:', e);
            }
        }

        // Play whistle sound (for exercise start)
        function playWhistle() {
            if (!document.getElementById('soundEnabled').checked) return;
            initAudio();

            // Create a whistle-like sound with frequency sweep
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(1800, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(2400, audioContext.currentTime + 0.1);
            oscillator.frequency.exponentialRampToValueAtTime(2000, audioContext.currentTime + 0.3);

            gainNode.gain.setValueAtTime(0.9, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.4);
        }

        // Play countdown beep
        function playCountdownBeep() {
            playBeep(600, 0.15, 'sine', 0.8);
        }

        // Play exercise end sound (loud descending pitch to signal stop)
        function playExerciseEnd() {
            if (!document.getElementById('soundEnabled').checked) return;
            try {
                initAudio();

                // Create a loud descending pitch sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'square'; // Square wave is louder/more noticeable

                // Start high and descend
                oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.4);

                // Loud volume with gradual fade
                gainNode.gain.setValueAtTime(0.7, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.7, audioContext.currentTime + 0.3);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.warn('Audio playback error:', e);
            }
        }

        // Play celebration sound
        function playCelebration() {
            if (!document.getElementById('soundEnabled').checked) return;
            initAudio();

            const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                setTimeout(() => {
                    playBeep(freq, 0.3, 'sine');
                }, i * 150);
            });
        }

        // Toggle timer settings panel
        function toggleTimerSettings() {
            const panel = document.getElementById('timerSettings');
            panel.classList.toggle('collapsed');
        }

        // Calculate total workout time
        function calculateTotalTime() {
            const settings = getTimerSettings();
            const exerciseCount = selectedExercises.filter(e => e).length || 6;

            // Per cycle: exercises + rest between exercises
            const exerciseTime = exerciseCount * settings.exerciseDuration;
            const restTime = (exerciseCount - 1) * settings.restDuration;
            const cycleTime = exerciseTime + restTime;

            // Total: all cycles + rest between cycles
            const totalCycleTime = cycleTime * settings.numCycles;
            const cycleRestTime = settings.cycleRestDuration * (settings.numCycles - 1);

            // Add initial countdown
            const totalSeconds = totalCycleTime + cycleRestTime + settings.countdownDuration;

            return totalSeconds;
        }

        // Update timer summary display
        function updateTimerSummary() {
            const totalSeconds = calculateTotalTime();
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            document.getElementById('totalWorkoutTime').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Enable/disable start button based on exercise selection
            const hasExercises = selectedExercises.filter(e => e).length >= 1;
            document.getElementById('startTimerBtn').disabled = !hasExercises;
        }

        // Get current timer settings
        function getTimerSettings() {
            return {
                exerciseDuration: parseInt(document.getElementById('exerciseDuration').value) || 30,
                restDuration: parseInt(document.getElementById('restDuration').value) || 15,
                cycleRestDuration: parseInt(document.getElementById('cycleRestDuration').value) || 30,
                numCycles: parseInt(document.getElementById('numCycles').value) || 5,
                countdownDuration: parseInt(document.getElementById('countdownDuration').value) || 15
            };
        }

        // Format seconds as MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update the circular progress ring
        function updateProgressRing(progress) {
            const circumference = 2 * Math.PI * 44; // r=44
            const offset = circumference * (1 - progress);
            document.getElementById('timerRingProgress').style.strokeDashoffset = offset;
        }

        // Update timer display
        function updateTimerDisplay() {
            const overlay = document.getElementById('timerOverlay');
            const phaseLabel = document.getElementById('timerPhaseLabel');
            const exerciseName = document.getElementById('timerExerciseName');
            const countdown = document.getElementById('timerCountdown');
            const nextUp = document.getElementById('timerNextUp');
            const nextExercise = document.getElementById('timerNextExercise');

            // Update countdown number
            countdown.textContent = timerState.secondsRemaining;

            // Add warning class for last 3 seconds
            if (timerState.secondsRemaining <= 3 && timerState.secondsRemaining > 0) {
                countdown.classList.add('warning');
            } else {
                countdown.classList.remove('warning');
            }

            // Update progress ring
            const progress = timerState.secondsRemaining / timerState.phaseDuration;
            updateProgressRing(progress);

            // Update total remaining
            document.getElementById('timerTotalRemaining').textContent = formatTime(timerState.totalSecondsRemaining);

            // Update cycle/exercise counters
            document.getElementById('timerCurrentCycle').textContent = timerState.currentCycle;
            document.getElementById('timerTotalCycles').textContent = timerSettings.numCycles;
            document.getElementById('timerCurrentExercise').textContent = timerState.currentExerciseIndex + 1;

            // Update phase-specific display
            overlay.className = 'timer-overlay active';

            const exercises = selectedExercises.filter(e => e);
            const exercisesPerCycle = megaMoveMode ?
                6 :
                exercises.length;

            switch (timerState.currentPhase) {
                case 'countdown':
                    overlay.classList.add('countdown-phase');
                    phaseLabel.textContent = megaMoveMode ? 'MEGA MOVE - GET READY' : 'GET READY';
                    exerciseName.textContent = megaMoveMode ?
                        (currentMegaMoveExercise?.name || 'Random Exercise') :
                        (exercises[0]?.name || 'Exercise 1');
                    nextUp.style.display = 'none';
                    break;

                case 'exercise':
                    overlay.classList.add('exercise-phase');
                    phaseLabel.textContent = megaMoveMode ? 'MEGA MOVE' : 'EXERCISE';
                    exerciseName.textContent = megaMoveMode ?
                        (currentMegaMoveExercise?.name || 'Random Exercise') :
                        (exercises[timerState.currentExerciseIndex]?.name || `Exercise ${timerState.currentExerciseIndex + 1}`);

                    // Show next up
                    const nextIdx = timerState.currentExerciseIndex + 1;
                    if (nextIdx < exercisesPerCycle) {
                        nextUp.style.display = 'block';
                        nextExercise.textContent = megaMoveMode ?
                            (nextMegaMoveExercise?.name || 'Random exercise') :
                            (exercises[nextIdx]?.name || `Exercise ${nextIdx + 1}`);
                    } else if (timerState.currentCycle < timerSettings.numCycles) {
                        nextUp.style.display = 'block';
                        nextExercise.textContent = megaMoveMode ?
                            `Cycle ${timerState.currentCycle + 1}: ${nextMegaMoveExercise?.name || 'Random'}` :
                            `Cycle ${timerState.currentCycle + 1} - ${exercises[0]?.name}`;
                    } else {
                        nextUp.style.display = 'block';
                        nextExercise.textContent = 'Finish!';
                    }
                    break;

                case 'rest':
                    overlay.classList.add('rest-phase');
                    phaseLabel.textContent = 'REST';
                    exerciseName.textContent = megaMoveMode ?
                        (currentMegaMoveExercise?.name || 'Random Exercise') :
                        (exercises[timerState.currentExerciseIndex + 1]?.name || `Exercise ${timerState.currentExerciseIndex + 2}`);
                    nextUp.style.display = 'block';
                    nextExercise.textContent = 'Coming up next...';
                    break;

                case 'cycleRest':
                    overlay.classList.add('cycle-rest-phase');
                    phaseLabel.textContent = `CYCLE ${timerState.currentCycle} COMPLETE`;
                    exerciseName.textContent = 'Rest';
                    nextUp.style.display = 'block';
                    nextExercise.textContent = megaMoveMode ?
                        `Cycle ${timerState.currentCycle + 1}: ${currentMegaMoveExercise?.name || 'Random exercise'}` :
                        `Cycle ${timerState.currentCycle + 1} starting with: ${exercises[0]?.name}`;
                    break;

                case 'complete':
                    overlay.classList.add('complete-phase');
                    showCompleteScreen();
                    break;
            }

            // Update pause button
            const pauseBtn = document.getElementById('timerPauseBtn');
            pauseBtn.textContent = timerState.isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        }

        // Show completion screen
        function showCompleteScreen() {
            const main = document.getElementById('timerMain');
            const exercises = selectedExercises.filter(e => e);
            const exercisesPerCycle = megaMoveMode ?
                6 :
                exercises.length;
            const totalExercises = exercisesPerCycle * timerSettings.numCycles;
            const totalTime = megaMoveMode ? calculateMegaMoveTime() : calculateTotalTime();

            main.innerHTML = `
                <div class="timer-complete">
                    <div class="timer-complete-icon">üéâ</div>
                    <div class="timer-complete-message">${megaMoveMode ? 'Mega Move Complete!' : 'Workout Complete!'}</div>
                    <div class="timer-complete-stats">
                        <div class="timer-complete-stat">
                            <div class="value">${timerSettings.numCycles}</div>
                            <div class="label">Cycles</div>
                        </div>
                        <div class="timer-complete-stat">
                            <div class="value">${totalExercises}</div>
                            <div class="label">Exercises</div>
                        </div>
                        <div class="timer-complete-stat">
                            <div class="value">${formatTime(totalTime)}</div>
                            <div class="label">Duration</div>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="stopTimer()" style="font-size: 1.2rem; padding: 15px 40px;">
                        ‚úì Done
                    </button>
                </div>
            `;
        }

        // Reset timer main content
        function resetTimerMain() {
            const main = document.getElementById('timerMain');
            main.innerHTML = `
                <div class="timer-phase-label" id="timerPhaseLabel">GET READY</div>
                <div class="timer-exercise-name" id="timerExerciseName">Starting...</div>

                <div class="timer-countdown-container">
                    <div class="timer-countdown-ring">
                        <svg viewBox="0 0 100 100">
                            <circle class="ring-bg" cx="50" cy="50" r="44"></circle>
                            <circle class="ring-progress" id="timerRingProgress" cx="50" cy="50" r="44"
                                    stroke-dasharray="276.46" stroke-dashoffset="0"></circle>
                        </svg>
                    </div>
                    <div class="timer-countdown-number" id="timerCountdown">0</div>
                </div>

                <div class="timer-next-up" id="timerNextUp">
                    <div class="label">Next Up</div>
                    <div class="exercise" id="timerNextExercise">--</div>
                </div>
            `;
        }

        // Start the timer
        async function startTimer() {
            const exercises = selectedExercises.filter(e => e);
            if (exercises.length === 0) {
                showWarning('Please select at least one exercise first!');
                return;
            }

            // Initialize audio on user interaction
            initAudio();

            // Reset mega move mode (using regular workout)
            megaMoveMode = false;

            // Get settings
            timerSettings = getTimerSettings();

            // Request wake lock
            try {
                if ('wakeLock' in navigator) {
                    timerState.wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) {
                console.log('Wake Lock not supported or denied');
            }

            // Initialize timer state
            timerState.isRunning = true;
            timerState.isPaused = false;
            timerState.currentCycle = 1;
            timerState.currentExerciseIndex = 0;
            timerState.currentPhase = 'countdown';
            timerState.secondsRemaining = timerSettings.countdownDuration;
            timerState.phaseDuration = timerSettings.countdownDuration;
            timerState.totalSecondsRemaining = calculateTotalTime();

            // Reset the main content in case it was showing complete screen
            resetTimerMain();

            // Show overlay
            document.getElementById('timerOverlay').classList.add('active');
            updateTimerDisplay();

            // Start the interval
            timerState.intervalId = setInterval(timerTick, 1000);
        }

        // Get all enabled exercises from the library
        function getAllEnabledExercises() {
            const enabledExercises = [];
            Object.keys(exerciseData).forEach(category => {
                exerciseData[category].forEach(ex => {
                    const key = `${category}|${ex.name}`;
                    if (toggleStates[key] !== false) {
                        enabledExercises.push({
                            name: ex.name,
                            category: category,
                            link: ex.link
                        });
                    }
                });
            });
            return enabledExercises;
        }

        // Pick a random exercise from the mega move pool
        function pickRandomMegaMoveExercise() {
            if (megaMoveExercisePool.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * megaMoveExercisePool.length);
            return megaMoveExercisePool[randomIndex];
        }

        // Start mega move circuit - random exercise each interval
        async function startMegaMoveCircuit() {
            // Get all enabled exercises
            megaMoveExercisePool = getAllEnabledExercises();

            if (megaMoveExercisePool.length === 0) {
                showWarning('No exercises are enabled! Enable some exercises to use Mega Move Circuit.');
                return;
            }

            if (megaMoveExercisePool.length < 5) {
                showWarning(`Only ${megaMoveExercisePool.length} exercises enabled. Enable more for variety!`);
            }

            // Initialize audio on user interaction
            initAudio();

            // Get settings
            timerSettings = getTimerSettings();

            // Request wake lock
            try {
                if ('wakeLock' in navigator) {
                    timerState.wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) {
                console.log('Wake Lock not supported or denied');
            }

            // Set mega move mode
            megaMoveMode = true;

            // Pick first exercise and preview next exercise
            currentMegaMoveExercise = pickRandomMegaMoveExercise();
            nextMegaMoveExercise = pickRandomMegaMoveExercise();

            // Initialize timer state
            timerState.isRunning = true;
            timerState.isPaused = false;
            timerState.currentCycle = 1;
            timerState.currentExerciseIndex = 0;
            timerState.currentPhase = 'countdown';
            timerState.secondsRemaining = timerSettings.countdownDuration;
            timerState.phaseDuration = timerSettings.countdownDuration;
            timerState.totalSecondsRemaining = calculateMegaMoveTime();

            // Reset the main content in case it was showing complete screen
            resetTimerMain();

            // Show overlay
            document.getElementById('timerOverlay').classList.add('active');
            updateTimerDisplay();

            // Start the interval
            timerState.intervalId = setInterval(timerTick, 1000);
        }

        // Calculate total time for mega move circuit
        function calculateMegaMoveTime() {
            const exercisesPerCycle = 6; // Fixed at 6 exercises per cycle
            const cycleTime = (exercisesPerCycle * timerSettings.exerciseDuration) +
                              ((exercisesPerCycle - 1) * timerSettings.restDuration);
            const totalCycleTime = cycleTime * timerSettings.numCycles;
            const totalCycleRest = timerSettings.cycleRestDuration * (timerSettings.numCycles - 1);
            return timerSettings.countdownDuration + totalCycleTime + totalCycleRest;
        }

        // Timer tick (called every second)
        function timerTick() {
            if (timerState.isPaused) return;

            // Countdown beeps for last 3 seconds
            if (timerState.secondsRemaining <= 3 && timerState.secondsRemaining > 0) {
                playCountdownBeep();
            }

            timerState.secondsRemaining--;
            timerState.totalSecondsRemaining--;

            if (timerState.secondsRemaining < 0) {
                advancePhase();
            }

            updateTimerDisplay();
        }

        // Advance to next phase
        function advancePhase() {
            const exercises = selectedExercises.filter(e => e);
            const exercisesPerCycle = megaMoveMode ?
                6 :
                exercises.length;

            switch (timerState.currentPhase) {
                case 'countdown':
                    // Start first exercise (currentMegaMoveExercise already set in startMegaMoveCircuit)
                    playWhistle();
                    timerState.currentPhase = 'exercise';
                    timerState.secondsRemaining = timerSettings.exerciseDuration;
                    timerState.phaseDuration = timerSettings.exerciseDuration;
                    break;

                case 'exercise':
                    // Play sound to indicate exercise ended
                    playExerciseEnd();
                    // Check if there are more exercises in this cycle
                    if (timerState.currentExerciseIndex < exercisesPerCycle - 1) {
                        // Rest before next exercise
                        timerState.currentPhase = 'rest';
                        timerState.secondsRemaining = timerSettings.restDuration;
                        timerState.phaseDuration = timerSettings.restDuration;
                        // For mega move: current becomes next, pick new next
                        if (megaMoveMode) {
                            currentMegaMoveExercise = nextMegaMoveExercise;
                            nextMegaMoveExercise = pickRandomMegaMoveExercise();
                        }
                    } else if (timerState.currentCycle < timerSettings.numCycles) {
                        // Cycle complete, longer rest
                        timerState.currentPhase = 'cycleRest';
                        timerState.secondsRemaining = timerSettings.cycleRestDuration;
                        timerState.phaseDuration = timerSettings.cycleRestDuration;
                        // For mega move: current becomes next, pick new next for next cycle
                        if (megaMoveMode) {
                            currentMegaMoveExercise = nextMegaMoveExercise;
                            nextMegaMoveExercise = pickRandomMegaMoveExercise();
                        }
                    } else {
                        // Workout complete!
                        completeWorkout();
                    }
                    break;

                case 'rest':
                    // Start next exercise (exercise already picked when entering rest)
                    playWhistle();
                    timerState.currentExerciseIndex++;
                    timerState.currentPhase = 'exercise';
                    timerState.secondsRemaining = timerSettings.exerciseDuration;
                    timerState.phaseDuration = timerSettings.exerciseDuration;
                    break;

                case 'cycleRest':
                    // Start next cycle (exercise already picked when entering cycleRest)
                    playWhistle();
                    timerState.currentCycle++;
                    timerState.currentExerciseIndex = 0;
                    timerState.currentPhase = 'exercise';
                    timerState.secondsRemaining = timerSettings.exerciseDuration;
                    timerState.phaseDuration = timerSettings.exerciseDuration;
                    break;
            }
        }

        // Complete the workout
        function completeWorkout() {
            timerState.currentPhase = 'complete';
            timerState.isRunning = false;
            clearInterval(timerState.intervalId);
            playCelebration();
            updateTimerDisplay();
        }

        // Toggle pause
        function togglePause() {
            timerState.isPaused = !timerState.isPaused;

            // Show/hide paused indicator
            const pausedIndicator = document.getElementById('timerPausedIndicator');
            const pauseBtn = document.getElementById('timerPauseBtn');
            if (timerState.isPaused) {
                pausedIndicator.classList.add('active');
                pauseBtn.textContent = '‚ñ∂Ô∏è';
            } else {
                pausedIndicator.classList.remove('active');
                pauseBtn.textContent = '‚è∏Ô∏è';
            }

            updateTimerDisplay();
        }

        // Calculate total remaining time based on current position
        function recalculateTotalRemaining() {
            const exercises = selectedExercises.filter(e => e);
            const exerciseCount = exercises.length;
            let total = 0;

            // Add current phase remaining time
            total += timerState.secondsRemaining;

            // Calculate remaining time based on current phase and position
            if (timerState.currentPhase === 'countdown') {
                // All cycles still to come
                const cycleTime = (exerciseCount * timerSettings.exerciseDuration) +
                                  ((exerciseCount - 1) * timerSettings.restDuration);
                total += cycleTime * timerSettings.numCycles;
                total += timerSettings.cycleRestDuration * (timerSettings.numCycles - 1);
            } else if (timerState.currentPhase === 'exercise') {
                // Remaining exercises in current cycle
                const remainingInCycle = exerciseCount - timerState.currentExerciseIndex - 1;
                total += remainingInCycle * timerSettings.exerciseDuration;
                total += remainingInCycle * timerSettings.restDuration;

                // Remaining cycles
                const remainingCycles = timerSettings.numCycles - timerState.currentCycle;
                if (remainingCycles > 0) {
                    total += timerSettings.cycleRestDuration; // Rest after current cycle
                    const cycleTime = (exerciseCount * timerSettings.exerciseDuration) +
                                      ((exerciseCount - 1) * timerSettings.restDuration);
                    total += cycleTime * remainingCycles;
                    total += timerSettings.cycleRestDuration * (remainingCycles - 1);
                }
            } else if (timerState.currentPhase === 'rest') {
                // Remaining exercises in current cycle (including the one after this rest)
                const remainingInCycle = exerciseCount - timerState.currentExerciseIndex - 1;
                total += remainingInCycle * timerSettings.exerciseDuration;
                total += (remainingInCycle - 1) * timerSettings.restDuration;

                // Remaining cycles
                const remainingCycles = timerSettings.numCycles - timerState.currentCycle;
                if (remainingCycles > 0) {
                    total += timerSettings.cycleRestDuration;
                    const cycleTime = (exerciseCount * timerSettings.exerciseDuration) +
                                      ((exerciseCount - 1) * timerSettings.restDuration);
                    total += cycleTime * remainingCycles;
                    total += timerSettings.cycleRestDuration * (remainingCycles - 1);
                }
            } else if (timerState.currentPhase === 'cycleRest') {
                // All remaining cycles
                const remainingCycles = timerSettings.numCycles - timerState.currentCycle;
                const cycleTime = (exerciseCount * timerSettings.exerciseDuration) +
                                  ((exerciseCount - 1) * timerSettings.restDuration);
                total += cycleTime * remainingCycles;
                total += timerSettings.cycleRestDuration * (remainingCycles - 1);
            }

            timerState.totalSecondsRemaining = Math.max(0, total);
        }

        // Skip forward
        function skipForward() {
            if (!timerState.isRunning || timerState.currentPhase === 'complete') return;

            // Set seconds to 0 and advance phase (don't play sounds on skip)
            timerState.secondsRemaining = 0;

            // Manually advance phase without sounds
            const exercises = selectedExercises.filter(e => e);

            switch (timerState.currentPhase) {
                case 'countdown':
                    timerState.currentPhase = 'exercise';
                    timerState.secondsRemaining = timerSettings.exerciseDuration;
                    timerState.phaseDuration = timerSettings.exerciseDuration;
                    break;

                case 'exercise':
                    if (timerState.currentExerciseIndex < exercises.length - 1) {
                        timerState.currentPhase = 'rest';
                        timerState.secondsRemaining = timerSettings.restDuration;
                        timerState.phaseDuration = timerSettings.restDuration;
                    } else if (timerState.currentCycle < timerSettings.numCycles) {
                        timerState.currentPhase = 'cycleRest';
                        timerState.secondsRemaining = timerSettings.cycleRestDuration;
                        timerState.phaseDuration = timerSettings.cycleRestDuration;
                    } else {
                        completeWorkout();
                        return;
                    }
                    break;

                case 'rest':
                    timerState.currentExerciseIndex++;
                    timerState.currentPhase = 'exercise';
                    timerState.secondsRemaining = timerSettings.exerciseDuration;
                    timerState.phaseDuration = timerSettings.exerciseDuration;
                    break;

                case 'cycleRest':
                    timerState.currentCycle++;
                    timerState.currentExerciseIndex = 0;
                    timerState.currentPhase = 'exercise';
                    timerState.secondsRemaining = timerSettings.exerciseDuration;
                    timerState.phaseDuration = timerSettings.exerciseDuration;
                    break;
            }

            recalculateTotalRemaining();
            updateTimerDisplay();
        }

        // Skip back
        function skipBack() {
            if (!timerState.isRunning || timerState.currentPhase === 'complete') return;

            const exercises = selectedExercises.filter(e => e);

            if (timerState.currentPhase === 'countdown') {
                // Just restart countdown
                timerState.secondsRemaining = timerSettings.countdownDuration;
                timerState.phaseDuration = timerSettings.countdownDuration;
            } else if (timerState.currentPhase === 'exercise' && timerState.currentExerciseIndex > 0) {
                // Go to previous exercise
                timerState.currentExerciseIndex--;
                timerState.secondsRemaining = timerSettings.exerciseDuration;
                timerState.phaseDuration = timerSettings.exerciseDuration;
            } else if (timerState.currentPhase === 'rest') {
                // Go back to current exercise
                timerState.currentPhase = 'exercise';
                timerState.secondsRemaining = timerSettings.exerciseDuration;
                timerState.phaseDuration = timerSettings.exerciseDuration;
            } else if (timerState.currentPhase === 'cycleRest') {
                // Go back to last exercise of current cycle
                timerState.currentExerciseIndex = exercises.length - 1;
                timerState.currentPhase = 'exercise';
                timerState.secondsRemaining = timerSettings.exerciseDuration;
                timerState.phaseDuration = timerSettings.exerciseDuration;
            } else if (timerState.currentPhase === 'exercise' && timerState.currentExerciseIndex === 0 && timerState.currentCycle > 1) {
                // Go to previous cycle's last exercise
                timerState.currentCycle--;
                timerState.currentExerciseIndex = exercises.length - 1;
                timerState.secondsRemaining = timerSettings.exerciseDuration;
                timerState.phaseDuration = timerSettings.exerciseDuration;
            } else if (timerState.currentPhase === 'exercise' && timerState.currentExerciseIndex === 0 && timerState.currentCycle === 1) {
                // Go back to countdown
                timerState.currentPhase = 'countdown';
                timerState.secondsRemaining = timerSettings.countdownDuration;
                timerState.phaseDuration = timerSettings.countdownDuration;
            } else {
                // Just restart current phase
                timerState.secondsRemaining = timerState.phaseDuration;
            }

            recalculateTotalRemaining();
            updateTimerDisplay();
        }

        // Stop timer
        function stopTimer() {
            timerState.isRunning = false;
            timerState.isPaused = false;
            clearInterval(timerState.intervalId);

            // Release wake lock
            if (timerState.wakeLock) {
                timerState.wakeLock.release();
                timerState.wakeLock = null;
            }

            // Reset mega move mode
            megaMoveMode = false;
            megaMoveExercisePool = [];
            currentMegaMoveExercise = null;
            nextMegaMoveExercise = null;

            // Hide overlay
            document.getElementById('timerOverlay').classList.remove('active');

            // Reset main content
            resetTimerMain();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!timerState.isRunning) return;

            switch (e.code) {
                case 'Space':
                    e.preventDefault();
                    togglePause();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    skipForward();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    skipBack();
                    break;
                case 'Escape':
                    e.preventDefault();
                    stopTimer();
                    break;
            }
        });

        // Touch swipe gestures for timer (mobile)
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        const timerOverlay = document.getElementById('timerOverlay');

        timerOverlay.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        timerOverlay.addEventListener('touchend', (e) => {
            if (!timerState.isRunning) return;

            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;

            handleSwipe();
        }, { passive: true });

        function handleSwipe() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const minSwipeDistance = 50;

            // Only register horizontal swipes (ignore vertical scrolling)
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0) {
                    // Swipe right - go back
                    skipBack();
                } else {
                    // Swipe left - skip forward
                    skipForward();
                }
            }
        }

        // Tap to pause/resume on timer main area (not buttons)
        document.getElementById('timerMain').addEventListener('click', (e) => {
            // Only trigger if clicking on the main area, not on buttons
            if (e.target.closest('.timer-controls') || e.target.closest('button')) return;
            if (!timerState.isRunning || timerState.currentPhase === 'complete') return;

            togglePause();
        });

        // Update timer summary when exercises change
        const originalRenderSelectedExercises = renderSelectedExercises;
        renderSelectedExercises = function(animate = false) {
            originalRenderSelectedExercises(animate);
            updateTimerSummary();
        };

        // Initialize timer summary on load and collapse settings by default
        setTimeout(() => {
            updateTimerSummary();
            // Collapse timer settings by default
            document.getElementById('timerSettings').classList.add('collapsed');
        }, 100);

        // ==================== EXERCISE INFO MODAL ====================
        function showExerciseInfo(exerciseName, videoLink = null) {
            const modal = document.getElementById('exerciseModal');
            const overlay = document.getElementById('exerciseModalOverlay');
            const titleEl = document.getElementById('exerciseModalTitle');
            const animationEl = document.getElementById('exerciseModalAnimation');
            const tipsEl = document.getElementById('exerciseModalTips');
            const footerEl = document.getElementById('exerciseModalFooter');

            // Set title
            titleEl.textContent = exerciseName;

            // Hide animation container (no longer used)
            animationEl.style.display = 'none';

            // Get tips - check if getExerciseTips function is available
            let tips;
            if (typeof getExerciseTips === 'function') {
                tips = getExerciseTips(exerciseName);
            } else {
                console.error('exercise-reference.js not loaded - getExerciseTips function not found');
                tips = ['Exercise tips could not be loaded. Please check that exercise-reference.js is available.'];
            }
            tipsEl.innerHTML = tips.map(tip => `<li>${tip}</li>`).join('');

            // Set video link if available
            if (videoLink) {
                footerEl.innerHTML = `<a href="${videoLink}" target="_blank" rel="noopener noreferrer">Watch Video Demo</a>`;
                footerEl.style.display = 'block';
            } else {
                footerEl.style.display = 'none';
            }

            // Show modal
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeExerciseModal() {
            const overlay = document.getElementById('exerciseModalOverlay');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        // Close modal on overlay click - wrapped in DOMContentLoaded to ensure element exists
        document.addEventListener('DOMContentLoaded', function() {
            const modalOverlay = document.getElementById('exerciseModalOverlay');
            if (modalOverlay) {
                modalOverlay.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeExerciseModal();
                    }
                });
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeExerciseModal();
            }
        });
    </script>

    <!-- Exercise Info Modal -->
    <div class="exercise-modal-overlay" id="exerciseModalOverlay">
        <div class="exercise-modal" id="exerciseModal">
            <div class="exercise-modal-header">
                <h3 id="exerciseModalTitle">Exercise Name</h3>
                <button class="exercise-modal-close" onclick="closeExerciseModal()">&times;</button>
            </div>
            <div class="exercise-modal-body">
                <div class="exercise-animation-container" id="exerciseModalAnimation">
                    <!-- Animation will be inserted here -->
                </div>
                <ul class="exercise-tips" id="exerciseModalTips">
                    <!-- Tips will be inserted here -->
                </ul>
            </div>
            <div class="exercise-modal-footer" id="exerciseModalFooter">
                <a href="#" target="_blank">Watch Video Demo</a>
            </div>
        </div>
    </div>

    <!-- Disclaimer Footer -->
    <footer class="disclaimer-footer">
        <p>This app is for informational purposes only. Consult a physician before starting any exercise program.
        By using this app, you assume all risk of injury. Not a substitute for professional fitness instruction.</p>
    </footer>
</body>
</html>
